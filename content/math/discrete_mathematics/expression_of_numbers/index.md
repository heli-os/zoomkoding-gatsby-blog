---
emoji: 
title: 보수
date: '2023-01-05 18:37:00'
author: Roach
tags: math
categories: 이산수학
---

## 컴퓨터에서의 수의 표현

보수에 관한 내용을 들어가기 앞서 컴퓨터에서 수를 표현하는 방법을 간단하게 생각해보자.  
2진수만으로 양의 부호, 음의 부호나 뺄셈 등을 구현하는건 참 어려운 일이다.  
컴퓨터에서는 음수를 어떻게 표현할까? 오늘은 그 개념을 정리해보려고 한다.

> 이 글을 읽으면서 느꼈으면 좋겠는건, 1의 보수가 기존처럼 단순히 1 과 0 을 반대로 뒤집는 걸 생각하지말고, 왜 그렇게 뒤집는지를 꼭 생각해보길 바란다.

## 보수(Complement)

보수는 **보충해주는 수**를 의미한다. 수학적으로 간단하게 표기하자면 아래와 같다.

```
a + c(보수) = b 
```

a 가 b 가 되기 위해 보충해주는 C(Complement) 가 바로 보수이다.  
그래서 보충해주는 수라는 의미로 **보수**라고 불린다.
- 10 진수(base) 체계에서 1에 대한 10의 보수는 9이다.

하지만 b 가 꼭 b 일 필요는 없고, **b 의 제곱수**일수도 있다.  
예를 들면, 2 진수의 경우 0, 2, 4, 6, 8 일수도 있는 것이다.  

그럼 12에 대한 10의 보수는 무엇일까? 88이다.

여기서 한가지 특징이 있는데, **n 진법에 대한 n 의 보수와 임의의 수 a 의 합은 carry(이 표현이 맞나 싶네..) 를 일으키게 된다.**

> carry : 한자릿수가 더 높아지는 경우, 예를 들면 두자릿수에서 세자리수로 변할때

## 2의 보수

위에서 설명했듯 2의 보수 또한 어떤 수 a 가 보수와 더해져서 2의 제곱수 중 하나가 될 수 있는 것을 의미한다.  
또한 위 처럼 어떤 수 a 와 2의 보수 c 를 더했을때 캐리가 발생하게 된다.

```
 1110
 0010
-----
10000
```

## 음수를 표현하는 방법?

여기까지 보수가 어떤것인지 간단하게 알아보았다.  
그렇다면 컴퓨터는 이러한 방법을 이용해 어떻게 정수를 표현하는 걸까?

컴퓨터에서는 데이터를 처리할때 **워드(word)** 단위로 처리한다.  
워드의 **최상위 비트(MSB)** 에 숫자를 **부호**로, 나머지 비트는 값을 표현하는데 이용된다.

<img width="561" alt="image" src="https://user-images.githubusercontent.com/57784077/211182006-fe487e2b-e38c-4afa-87c5-caead0c8acc0.png">


위 그림의 숫자를 10진수로 바꿔보면 -31이다.
제일 앞자리인 1은 음수 부호를 나타내는 방식으로 컴퓨터에서는 정수를 표현한다.

## 부호-절댓값 표현(sign-magnitude)

부호 절댓값 표현은 우리가 위의 적은 방식과 동일하다.  
첫번째 자릿수에는 부호를 나타내는 비트를 적고, 나머지 자리에는 절댓값 숫자의 표현을 적는다. (어렵게 말해 절대값이지 그냥 십진수를 이진수로 바꾼 수 이다.)

<img width="561" alt="image" src="https://user-images.githubusercontent.com/57784077/211182006-fe487e2b-e38c-4afa-87c5-caead0c8acc0.png">

이 방식의 가장 큰 문제는 **+0 과 -0** 이라는 문제가 발생하게 된다. 따라서 이를 둘다 0으로 인식하게 해주기 위한 하나의 작업이 소요되게 된다. 그리고 연산시에 **부호와 절대값을 따로 표현해서 관리**하기 때문에 연산을 위한 덧셈기와 뺄셈기가 각각 필요하게 된다.

## 1의 보수 

보수도 위에서 설명했지만 여기서 한번 더 심화적으로 설명하고 넘어가겠다.

$R(기준치) = a(어떤 수) + c(보수)$ 

위와 같을 때 컴퓨터에서는 1의 갯수가 n 비트만큼 존재라고 하며, 기준치를 4비트로 잡을 경우 1의 보수에서는 **기준치가 1111** 이 된다. 이렇게 생각했을때 0110 의 보수를 구한다고 해보자.

```
1111 = 0110 + C
C = 1111 - 0110
C = 1001
```

이제 왜 1의 보수에서 0 과 1이 반전되는지 알게 되었을 것이다.  
자 그렇다면 이 방법을 이용해서 어떻게 보수 처리를 하는 것일까? 아래 수식을 한번 같이 살펴보자.

```
0 = a + C
a = 0 - C
a = -C
```

즉, 기준치가 0 일 경우, 어떤 수(a) 를 보수 처리한다는 것은 어떤 수(a) 의 음수와 같다는 말이다.  
따라서 1의 보수에서는 부호-절댓값 표현처럼 **덧셈, 뺄셈 연산기**를 따로 만들 필요가 없다. 보수 처리를 하고 더하는 방식을 이용하면 $a + (-C) = 0$ 과 같이 덧셈연산으로도 뺄셈 구현이 가능하기 때문이다.

눈치가 빠른 사람이라면 위의 기준치 0과 1111을 보고 눈치챘을수도 있다. 왜, 기준치를 0으로 잡아야 음수 표현이 가능한것인데, 왜 1111으로 잡는것인지 의아해 할 수 있다. 이것이, **1의 보수의 문제점인데 바로 음의 0과 양의 0이 따로 존재**한다. 설명을 위해 아래 수식을 한번 보자.

$0000 - 0000 = 0000$

위의 식을 1의 보수로 나타내어 덧셈 연산을 통해 뺄셈 연산을 하도록 해보자.

$0000 + 1111(0000의 1의 보수 처리) = 0000$

즉, 위의 수식이 성립하려면 1111 또한 0000 이여야 한다. 따라서 1111 이 음의 0 이되며, 0000 이 양의 0 이된다.

여기까지 1의 보수 방식을 봤을때, **부호-절댓값 표현** 보다도 괜찮아 보인다.  

## Carry(자리올림) 문제

이 문제는 n 진법에서 n - 1 의 보수를 활용하여 연산하려고 할때 발생하는 문제이다.  
좀 더 직관적으로 이해할 수 있도록, 10진법에서 9의 보수를 이용한다고 해보자.

21-41 을 9의 보수로 계산한다고 해봅시다.

```
21 + (99-41)
21 + 58 = 79
99 - 79 = 20

Carry 가 발생하지 않았으므로 음의 부호를 붙여 -20 이 된다.
```

N 의 보수를 통해 이렇게 연산이 가능하게 된다. 그럼 반대로도 한번 해보자.

```
41 - 21
41 + (99 - 21)
41 + (78)
119 (캐리 발생)

캐리가 발생했으므로 양수이고, 캐리가 발생한 자릿수는 버린다.
19

n - 1 의 보수이므로 n 의 보수로 표현되기 위해서는 +1 을 해준다.

20
```

위와 같은 n - 1 의 보수에서 carry 가 발생할경우 carry 가 발생한 자릿수는 버리고 +1 을 해줘야 한다는 것을 발견할 수 있다. 이렇게 1의 보수로 연산해서 캐리가 발생하는 경우 **+1 연산이 추가적으로 해야하는지 분기하는 판단하는 과정과 1을 더하는 로직이 더 필요**하게 된다.

## 2의 보수

그럼 2의 보수는 이러한 문제를 없애기 위해 이용될 것이다.   
일단 더 쉬운 설명을 위해 10진수로 한번 보도록 하자.  

아까의 41 - 21 을 10의 보수를 이용해서 계산해보겠다.

```
(41 + (100 - 21)) - 100
(41 + 79) - 100
120 - 100
20
```

위와 같이 10의 보수를 이용해서 하면 **1을 더하거나의 과정을 생각할 필요없이 연산이 쉽게 가능**하다.  
이제 왜 1의 보수에서 +1 을 더하는 것이 2의 보수가 되는길인지 알 것이라고 생각된다.

### 2의 보수에는 양의 0 과 음의 0이 존재하는가?

1의 보수에서는 0을 1111 으로 표현할 수 있었다.  
그럼 1의 보수를 2의 보수로 표현하면 1111 + 1 인 1 0000이 될 것이다.  
2의 보수에서는 Overflow 가 일어난 비트는 무시하므로 캐리된 1은 무시되며 0은 모두 0000으로 표현된다.