---
emoji: 
title: 함수형 프로그래밍 (액션 - 계산 - 데이터)
date: '2023-01-16 23:00:00'
author: Roach
tags: function-programming
categories: function-programming
---

# 함수형 프로그래밍?

최근 함수형 프로그래밍을 공부하려고, `함수형 코딩` 이라는 책을 샀다. 평소 함수형 프로그래밍에 대한 지식이 많이 필요하다고 느끼기도 하여 읽어보는데 첫 장에 **"액션-계산-데이터"** 를 잘 구분하는 것이 중요하다. 라고 나와있었다. 과연, 액션-계산-데이터는 무엇일까? 한번 알아보자.

## 계산

책에서 설명하는 **계산**의 정의는 **실행해도 다른 곳에 영향을 주지 않으며, 입력으로 출력을 계산**한다고 나와있다.  
보통, 입력이 같으면 출력이 같다는 설명도 많이 들어보았을 것이다. 예를 들면, 우리가 자바 혹은 다른 언어들에서 사용하는 언어 자체에서 제공해주는 Math.add(int a, int b) 등의 함수가 계산이다. 

주어진 입력값 `a`, `b` 를 넣었을때 `a+b` 가 나온다. 실행 순서에도 의존하지 않고, 항상 같은 결과를 도출해낸다.

## 액션(Action)

책에서 설명하는 **액션**의 정의는 **실행횟수와 호출시점에 의존**한다고 적혀있다.  
처음에 저렇게만 적혀있길래 아래와 같은 상황을 생각하며 아니 그럼 이것도 이책에서는 계산아니야? 이 생각을 했었다.

```
/* 메모리 문제를 절대로 일으키지 않고, 항상 Storage 에 사물을 저장함 */
fun Storage.register(obj: Obj): Unit
```

근데 뒷장에서 다시 설명하듯, 부수효과를 일으키는 함수는 Action 이라고 다시 추가적으로 설명해준다.  
그리고 사실 위의 방법보다 pacakge 를 잘 나누고, `fun register(storage: Storage)` 로 적는것이 좀 더 함수형적인 사고 방식으로 알고 있다. 
여하튼, Action 이란 보통 부수효과를 이용한다. 그렇기 때문에 **실행 순서에 의존**하는 경우가 많다.  

실행 순서 의존에 관한 코드는 뒤에서 다시 설명하겠다. 

## 데이터

데이터란 계산 혹은 액션을 하기 위해 사용되는 데이터 혹은 이벤트를 기록한 사실로 설명한다.   
함수형에서는 보통 값 컨텍스트를 유지하려고 노력한다. 불변성으로 데이터를 보존하면, Side-Effect 를 줄이고 계산 영역을 쉽게 늘릴 수 있기 때문이다.  
가변 데이터에 대한 함수를 작성할 경우 보통 Action 이 되어 버리고 만다. 왜냐하면 대부분의 상황에서 다른 곳에서 가변 데이터에 대한 Side-Effect 를 입힐 수 있기 때문이다.

## 참조 투명성

나는 함수형 프로그래밍에서 이 개념이 가장 재미있다고 생각한다.  
수학적으로 생각했을때 fun add(x, y) 에 x = 2, y = 4 를 넣었을때 항상 6이 나온다고 해보자.  
그렇다면 fun some(add(2, 4)) 일 경우 some(6) 으로 대체 가능하다. 즉, **계산은 계산된 값으로 대체가 가능**하다.  

## 계산과 값의 관계

여기서 위의 개념을 잘 생각하고, 함수형 코딩이라는 책의 냉장고 예시를 간단하게 설명해보겠다.  
우리가 장을 보러가기 위해 재고를 계산해야 한다. 장을 보기 위해서 필요한 것을 계산해야 할때 아래 프로세스를 따른다.

> 현재 재고 -> 필요한 재고 -> 재고 빼기 -> 장보기 목록 -> 목록에 있는 것 구입하기.

여기서 현재 재고는 현재 냉장고의 물품 재고를 뜻하고, 필요한 재고는 내가 사야하는 물품의 재고 목록이다.  
예를 들면, 현재 냉장고에 고등어가 2개 있을 경우 현재 재고에 **"고등어: 2" 이런식으로 적혀있을 것이고, 필요한 재고 "고등어: 2"** 일 경우 재고빼기를 통해 재고를 계산해보면 장보기 목록에 고등어를 적을 필요가 없게 된다.

여기서 재밌는건 책에서 "재고 빼기" 를 위 설명 후에 "재고 빼기" 를 계산이라고 말한다. 이 이유는 책에서 데이터를 불변이라고 설명하기 때문이다. 여기서 재밌는 상상을 하나 해보자. 책에서는 데이터가 불변이라고 했지만, 불변이 아니라고 생각해 보는 것 이다. 만약, 현재 재고가 냉장고의 현재 상황을 실시간으로 반영한다고 해보자. **내가 장보기 목록을 계산하려고 할때 냉장고에서 고등어가 1이 됬다면 어떨까?**  처음에 넘기는 시점에서는 분명히 "고등어: 2"로 넘겼지만, 계산 하려는 시점에 참조에 의해 값이 변경됬다고 해보자.
현재 재고가 Dictionary 자료구조라고 생각해보는것이다. 이렇게 됬을때는 "재고 빼기" 는 참조에 의한 값 변경의 영향을 받을 수 있으므로 **액션(Action)** 이 된다.  

```javascript
function getProductToBuy(inventory: Map<String, Int>, productToBuy: Map<String, Int>)
```

그럼 책에서 설명하는 것처럼 계산이 되려면 어떻게 해야할까?  
받는 인자를 **값**으로 넘겨주어야 한다. 함수형 프로그래밍에서 이는 상당히 중요하다.  

```javascript
function getProductToBuy(inventory: InventoryData, productToBuy: ProductToBuyData)
```

즉, 위와 같이 함수를 구성하되 `InventoryData` 와 `ProductToBuyData` 는 값이여야 한다.  
위 두 인자가 값일 경우 어떤 장점이 있을까? 아까의 **참조 투명성**을 통해 아래와 같은 코딩이 가능해진다.

```javascript
function getProductToBuy(inventory = getCurrentRefrigeratorData(), productToBuy = getProductToBuy())
```

기존의 값을 함수로 대체하는 것이 가능해졌다. **함수에 함수를 넘기는 "고차 함수" 를 이용하여 위와 같이 프로그래밍**이 가능해진다. 이 이유가 바로 함수형 프로그래밍에서는 기본적으로 값을 인자로 넘기는 이유 중 하나라고 생각한다.

결국 "계산을 구성하기 위해서는 값을 넘겨야 한다". 즉, 기존의 Action 에서 계산으로 추출할 수 있는 부분을 추출하기 위해서는 기존의 Action 에서 가변적으로 사용하던 State 들을 불변 상태인 값으로 만들고, 이를 통한 계산을 하는 방식으로 구성하여야 한다는 것이다. 

당연하게도 **모든 것을 계산으로 바꿀 수 없으므로**, 기존 코드의 큰 Action 뭉치에서 계산으로 추출할 부분을 찾는 것이 중요하다.  

## 끝마치며

자바에서 코틀린으로를 읽을때도 많이 나오는 내용이라 이미 한번 알고 있었지만, 이렇게 정리하고 나니 좀 더 머리에 잘 들어오는 느낌이다. 앞으로 코드를 작성할때 좀 더 많이 이용해봐야겠다는 생각도 든다.

그리고 책에서도 잘 알려주지만 값 컨텍스트를 이용하는게 항상 중요하다.

아 그리고 순서에 의존하는 부분은 [여기 링크](https://www.roach-dev.com/kotlin/kotlin_mutable/) 에서 **공유된 컬렉션을 변경하지 말라** 부분을 보면 된다.